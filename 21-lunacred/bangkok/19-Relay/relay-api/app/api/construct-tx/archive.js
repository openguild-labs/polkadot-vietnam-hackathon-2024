// The code below does not work as expected.
// It serves as a reference for how to construct a transaction using the txwrapper-polkadot library.

import {
    getRegistry,
    methods,
    construct,
    decode,
  } from "@substrate/txwrapper-polkadot";
  import { cryptoWaitReady } from "@polkadot/util-crypto";
  import { Keyring, ApiPromise, WsProvider } from "@polkadot/api";
  import { NextResponse } from "next/server";
  
  // Generated by subkey
  const relaySender = {
    secretPhrase:
      "tunnel genuine humble bicycle movie upset symbol mask timber hedgehog retreat march",
    networkId: "polkadot",
    secretSeed:
      "0x92a52533b3b0a45e8fc38a2ec6f2bf617447e3d13a36a7f1305a6364b441c624",
    publicKeyHex:
      "0x68e316749a77e96bfca62d6974d054dcfb32c52f1247e1e1496a3d9c075a9821",
    accountId:
      "0x68e316749a77e96bfca62d6974d054dcfb32c52f1247e1e1496a3d9c075a9821",
    publicKeySS58: "13NXSUJoBqVrJnLTcSMv87fymbH9FPVRXaKspxfBMrB2mqwv",
    ss58Address: "13NXSUJoBqVrJnLTcSMv87fymbH9FPVRXaKspxfBMrB2mqwv",
  };
  
  const relayReceiver = {
    secretPhrase:
      "fiscal law caution pumpkin obvious collect lecture nothing bachelor tiny keen dawn",
    networkId: "polkadot",
    secretSeed:
      "0x6d6efc0726d128d4d27aaf0cf576340b6bd163086fe47d5e9c5b128637fae4bf",
    publicKeyHex:
      "0x9c97116622473abb99ed6624ef9141bbca812c48f572f0a3c04af51e5c36c14b",
    accountId:
      "0x9c97116622473abb99ed6624ef9141bbca812c48f572f0a3c04af51e5c36c14b",
    publicKeySS58: "14YKM6saYUKJNCwKxGj767u9aG6suoDrqLHbyjkiqH6Rap2x",
    ss58Address: "14YKM6saYUKJNCwKxGj767u9aG6suoDrqLHbyjkiqH6Rap2x",
  };
  
  let registry = null;
  let metadataRpc = null;
  // Define the async function to handle the transaction
  export async function GET() {
    const provider = new WsProvider("wss://rococo-rpc.polkadot.io");
    const api = await ApiPromise.create({ provider });
    const nonce = await api.call.accountNonceApi.accountNonce(
      relaySender.ss58Address
    );
    console.log(`Nonce before is: ${nonce}`);
  
    const unsigned = await constructUnsigned(3);
    console.log("Unsigned transaction version: ", unsigned.version);
    // Create a signing payload to sign.
    const signingPayload = construct.signingPayload(unsigned, { registry });
    // Create a signature over the signing payload.
    const signature = await signWithRelay(signingPayload, registry);
  
    const signedTx = construct.signedTx(unsigned, signature, {
      metadataRpc,
      registry,
    });
  
    // Convert the signed transaction string into an `Extrinsic` type
    const extrinsic = api.createType('Extrinsic', signedTx);
    const txInfo = decode(signedTx, { metadataRpc, registry });
  
    await rpcToNode("author_submitExtrinsic", [extrinsic.toHex()]);
  
    const nonceAfter = await api.call.accountNonceApi.accountNonce(
      relaySender.ss58Address
    );
    console.log(`Nonce after is: ${nonceAfter}`);
  
    return new NextResponse(JSON.stringify({ msg: "Transaction sent" }), {
      status: 200,
    });
  }
  
  async function signWithRelay(signingPayload, registry) {
    // Wait for the promise to resolve async WASM
    await cryptoWaitReady();
  
    const keyring = new Keyring({ type: "sr25519" });
    const relay = keyring.addFromMnemonic(relaySender.secretPhrase);
  
    const { signature } = registry
      .createType("ExtrinsicPayload", signingPayload, {
        version: 4,
      })
      .sign(relay);
  
    return signature;
  }
  
  const rpcToNode = async (method, params) => {
    const res = await fetch("https://rococo-rpc.polkadot.io/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: method,
        params: params,
      }),
    });
  
    const result = await res.json();
    return result.result;
  };
  
  // Get part of the information needed to construct a transaction.
  const getUpToDateInfo = async () => {
    // 'chain_getBlock' - Get header and body of a relay chain block.
    const { block } = await rpcToNode("chain_getBlock");
    // 'chain_getBlockHash' - Get the block hash for a specific block, default to get the latest block.
    const blockHash = await rpcToNode("chain_getBlockHash");
    // 'chain_getBlockHash' - Get the block hash for block 0, i.e. genesis block.
    const genesisHash = await rpcToNode("chain_getBlockHash", [0]);
    // 'state_getMetadata' - Returns the runtime metadata. It is used to encode and decode transactions.
    metadataRpc = await rpcToNode("state_getMetadata");
    // 'state_getRuntimeVersion' - Get the runtime version.
    const { specVersion, transactionVersion, specName } = await rpcToNode(
      "state_getRuntimeVersion"
    );
  
    const blockNumber = parseInt(block.header.number, 16);
  
    return {
      blockNumber,
      blockHash,
      genesisHash,
      metadataRpc,
      specVersion,
      transactionVersion,
      specName,
    };
  };
  
  const constructUnsigned = async (nonce) => {
    // The SS58-encoded address of the sending account.
    const address = relaySender.ss58Address;
  
    // The nonce for this transaction. Assume this is the first transaction by this account.
    // The nonce queried from the System module does not account for pending transactions. We must track and increment the nonce manually if we want to submit multiple valid transactions at the same time.
    //
    // When query the nonce from the System module (e.g., api.query.system.account(address)), we get the current on-chain nonce. This nonce value indicates the number of successful transactions that have been included in blocks for that account.
    // However, if we submit multiple transactions in a short period, there may be pending transactions that are not yet included in a block but are already in the mempool. The on-chain nonce does not reflect these pending transactions.
    // If we query the nonce and immediately use it to submit several transactions without adjusting it manually, each transaction will have the same nonce. This causes conflicts because each transaction must have a unique, sequential nonce value.
    // const nonce = 7;
  
    // The tip to pay, in addition to fees.
    // Polkadot has a rather unique fee system, check it out here: https://wiki.polkadot.network/docs/learn-transactions#transaction-fees
    const tip = 0;
  
    // Optional, the number of blocks after the checkpoint for which a transaction is valid. If zero, the transaction is immortal.
    // Check it out here: https://wiki.polkadot.network/docs/build-protocol-info#transaction-mortality
    const eraPeriod = 64;
  
    // The SS58-encoded address of the sending account.
    const dest = relayReceiver.ss58Address;
  
    // Assume this is a balance transfer transaction. The value represents 0.5 DOT.
    // Check more about Polkadot token decimals here: https://wiki.polkadot.network/docs/build-protocol-info#tokens
    const value = 1_000_000_000_000;
  
    const {
      blockNumber,
      blockHash,
      genesisHash,
      metadataRpc,
      specVersion,
      transactionVersion,
      specName,
    } = await getUpToDateInfo();
  
    // Registry is used to encode and decode transactions.
    registry = getRegistry({
      chainName: "Rococo",
      specName,
      specVersion,
      metadataRpc,
    });
  
    const unsigned = methods.balances.transferKeepAlive(
      {
        dest,
        value,
      },
      {
        address,
        blockHash,
        blockNumber,
        genesisHash,
        metadataRpc,
        nonce,
        specVersion,
        tip,
        eraPeriod,
        transactionVersion,
      },
      {
        metadataRpc,
        registry,
      }
    );
  
    return unsigned;
  
    // There are two more optional parameters: mode and metadataHash.
    // Mode is a flag indicates whether to verify the metadata hash or not.
    // metadataHash should match the RUNTIME_METADATA_HASH environment variable.
    // Check the details here: https://wiki.polkadot.network/docs/build-transaction-construction
  };
  